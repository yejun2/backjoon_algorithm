서훈이는 오늘 있었던 알고리즘 과목 기말고사를 망쳐서 기분이 좋지 않다. 서훈이는 스트레스도 풀 겸 시험 문제로 나온 그래프를 불로 태우려고 한다.

서훈이는 그래프의 정점 (위 그림에서 동그라미로 표시된 곳) 중 한 곳에 불을 붙일 수 있다. 정점에 불이 붙으면 곧바로 노드와 연결된 간선을 따라서 불이 전달된다. 간선 위에서는 불은 1초당 1만큼의 거리를 이동한다. 
만약 어떤 간선의 양 끝 정점에 불이 붙은 경우 불은 간선의 중앙까지 태운 후 꺼진다.

서훈이는 그래프를 최대한 빠른 시간 안에 전부 태우고 싶어한다. 서훈이를 도와 어떤 정점에 불을 붙일지 구하는 프로그램을 작성하여라. 단, 위 그림에서 간선끼리 교차하는 것은 무시한다.

우선 정점을 태운다라는 개념을 보면, 정점과 간선을 전부 다 태워야 그래프를 태운다.

플로이드 워셜 알고리즘을 이용하면 각 출발점에서 각각의 정점으로 가는데 걸리는 시간을 구할 수 있다.
시간 복잡도는 정점의 개수가 N일때, O(N * N)이다.

처음 접근법은 low배열과 high배열에 각각 간선의 값을 저장한다. low는 최저값 high는 최댓값으로 저장한다.
low배열로 floyd-warshall을 값을 구한다.

그리고 high[i][j]의 값중 최댓값을 구한다.
이때, low[i][j] + high[i][k] 이런식으로 구했다. high는 low 값을 빼서 저장해두었다.

하지만, 여기서 이 문제의 가장 큰 트릭이 있다.
low[j][k] != low[i][k] - low[i][j] 이다. 그렇기 때문에 반복문을 돌면서 i->k로 갈때 긴 간선을 태우는 것을 볼때, high의 값에는 각 정점별로 계산이 필요하다.
j->k로 가는데에 걸리는 최소시간은 low[j][k]가 아닌 low[i][k] - low[i][j]이다. 그렇기때문에 이 시간을 high[j][k]에서 뻬고 나누기 2를 해서 각 출발점 별로 각 정점에 가는시간을 구할수있다. 여기서는 간선을 다 태우는것을 봐야하기때문에
max값으로 갱신해준다.
그래프를 다 태우는데에 걸리는 시간은 각 출발점별 max값을 가지는 정점중 min값이다.

그리고 경유지 설정을 하며 i->j->k순으로 삼중 반복문을 돌려야한다.
i->k를 갈때, j를 거치는 경로를 탐색하는것이며 j와 k사이에 연결되어있는 간선을 태우는 시간을 보는것이다. 그 중 max값을 채택해야 가장 긴 간선까지 태운다는 뜻이므로 max값을 채택하는 것이다.
