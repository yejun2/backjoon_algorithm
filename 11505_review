어떤 N개의 수가 주어져 있다. 그런데 중간에 수의 변경이 빈번히 일어나고 그 중간에 어떤 부분의 곱을 구하려 한다. 만약에 1, 2, 3, 4, 5 라는 수가 있고, 3번째 수를 6으로 바꾸고 2번째부터 5번째까지 곱을 구하라고 한다면 240을 출력하면 되는 것이다.
그리고 그 상태에서 다섯 번째 수를 2로 바꾸고 3번째부터 5번째까지 곱을 구하라고 한다면 48이 될 것이다.
N(1 ≤ N ≤ 1,000,000)과 M(1 ≤ M ≤ 10,000), K(1 ≤ K ≤ 10,000)

이러한 문제 유형을 본다면, 단순히 반복문으로 곱한다면 O(NM)이 된다.
시간 제한이 1초인데, 이러면 시간 초과가 난다.

구간의 합, 곱에 시간제한을 풀기 위해서는 세그먼트 트리를 이용하면 된다.
세그먼트 트리의 시간복잡도를 보자면 O(logN) * M이다.

처음에 틀린 이유를 분석해보자.
update시에 tree[node] *= num 이런식으로 재귀를 부르기전에 계산을 하였다.
이 경우 문제는 없다. 하지만 각 수는 1000000이하이므로 ll을 사용하여도 크기가 초과된다. 이 경우에는, 숫자를 바꿀때 값이 달라지는 것떄문에 틀렸다.

if (start == end) tree[node] = num; return;
이렇게 값을 바꾸고
update 시에 재귀를 먼저 부르고 tree[node] = tree[node*2] * tree[node*2+1] % 1000000007 로 각 트리의 값을 update하면 값의 교체에도 문제 없이 작동하게 된다.
재귀에서 return이 되면서 계산하므로 나누기 연산이 필요하지 않게 된다.
