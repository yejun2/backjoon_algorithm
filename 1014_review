최백준은 서강대학교에서 “컨닝의 기술”이라는 과목을 가르치고 있다. 이 과목은 상당히 까다롭기로 정평이 나있기 때문에, 몇몇 학생들은 시험을 보는 도중에 다른 사람의 답지를 베끼려 한다.

시험은 N행, M열 크기의 직사각형 교실에서 이루어진다. 교실은 1×1 크기의 단위 정사각형으로 이루어져 있는데, 각 단위 정사각형은 자리 하나를 의미한다.

최백준은 컨닝을 방지하기 위해서 다음과 같은 전략을 세웠다. 모든 학생은 자신의 왼쪽, 오른쪽, 왼쪽 대각선 위, 오른쪽 대각선 위, 이렇게 총 네 자리에 앉아있는 친구의 답지를 항상 베낀다고 가정한다. 따라서, 자리 배치는 모든 학생이 컨닝을 할 수 없도록 배치되어야 한다.



위의 그림을 보자. A, C, D 혹은 E에 다른 학생을 앉히는 것은 좋은 생각이 아니다. 그 이유는 이미 앉아있는 학생이 그들의 답안지를 베낄 우려가 있기 때문이다. 하지만, B에 다른 학생을 앉힌다면, 두 학생은 서로의 답지를 베낄 수 없어 컨닝의 우려가 없다.

위와 같이 컨닝이 불가능하도록 자리를 배치 하려는 최백준의 행동에 분노한 일부 학생들이 교실의 책상을 부숴버렸기 때문에, 일부 자리에는 학생이 앉을 수 없다.

최백준은 교실의 모양이 주어졌을 때, 이 곳에서 아무도 컨닝을 할 수 없도록 학생을 배치하였을 경우에 교실에 배치할 수 있는 최대 학생 수가 몇 명인지 궁금해졌다. 최백준을 위해 이를 구하는 프로그램을 작성하라.

이러한 내용의 문제이다.

--아이디어 흐름--

초기 생각은 dp와 dfs 중에 고민을 하였다.

하지만 dfs로 구현해본 결과 시간복잡도에서 문제가 있었고 dp로 풀어야된다는 생각을 하였다.

dp로 풀때, 결국 dfs를 사용하는것에서는 차이가 없다. 하지만, dp를 사용하여 시간 복잡도를 줄일 수 있다.

외판원 순회 문제에서 비트마스킹하여 같은 idx와 state일 경우에 dfs를 멈추고 dp에 저장된 값을 사용하였다.
이것과 같은 원리를 이용한다.

우선, 열을 기준으로 하여 보자. 열을 기준으로 어떤 자리에 학생이 앉을 때, 좌우자리에 다른 학생이 앉아있을 수 없다.
그래서 v라는 vector<int>에 한 열에 학생들을 앉힐 수 있는 모든 경우를 비트마스킹하여 추가한다.

dp[idx][state]로 보자.
idx는 몇번째 행인지를 나타내는 것이고, state는 그 행에 어떤 배치로 열에 앉아 있는지를 나타낸다.
dfs_dp를 보자면, 인자값으로 idx 와 state를 받는다. state는 이전의 state를 나타내는데, 이는 뒤에 행에 자리에 앉을 때 좌 우 대각선 위에
다른 학생이 앉아 있을 수 없기 때문이다.

가능한 모든 자리의 경우를 저장한 v를 반복하며, 그 배치가 이전의 상황을 고려하여 가능한 배치라는 재귀를 호출하고 아닌 경우에는 스킵하도록 한다.
당연하게도 dp에는 max의 값으로 갱신해준다.

초기에 dp의 모든 값을 -1로 설정을 하였는데, 만약 dp[idx][state] 의 값이 -1이 아니라면 해당 행의 해당 상태에서는 최댓값을 이미 서치해놓은것이므로,
그 값을 사용한다.

이 문제, 외판원 순회 문제에서도 비트마스킹 & **dp**을 써야하는 필요성에 집중해보자.

단순 dfs로 구현을 하면 시간 복잡도에서 안된다.

dp를 이용하게 되면 같은 idx에 같은 state에서의 중복 탐색의 경우를 피할 수 있고 이부분에서 시간복잡도를 개선할 수 있다.
dfs를 사용하는게 맞는 문제일 경우 dp와 연관지어 생각해보는 것도 하나의 솔루션이 될 수 있을거 같다.
