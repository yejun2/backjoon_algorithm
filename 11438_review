11438번 문제는 공통조상 알고리즘 문제이다.

기본적인 공통 조상 알고리즘 문제에서는 각 노드별 부모 노드의 번호를 가지고 level을 맞춘 후 각 부모로 올라가며 찾는 방식이지만, 이 방식 O(depth)의 시간 복잡도를 가진다.

이 문제에서는 O(depth)의 시간복잡도는 허용되지 않는다.

이분탐색을 이용한 LCA 알고리즘을 통해 O(log(depth)) 시간복잡도로 문제를 풀어보자.

log2(N)을 반내림하면 트리의 최대 깊이를 알 수 있다.

이분탐색을 위하여, 각 노드의 2 ** 0, 2 ** 1, 2 ** 2, ..... , 2 ** (floor(log2(N))의 부모를 저장한다.

만약 현재 노드에서 5번째 부모 노드가 찾는 대상이라면, 현재노드의 2 ** 2번째 부모의 2 ** 0번쨰 부모를 찾으면 된다.

parent[node][0] = pnode이다. 여기서 pnode는 자신의 직속 부모 노드를 뜻한다.

parent[node][i] = parent[parent[node][i-1]][i-1] 를 (0 < i <= maxDepth) 구간에서 반복하면 된다.

찾을때는 마찬가지로 level을 맞춘 후, 부모를 찾아간다.

이분탐색을 사용할 수 있으므로, level을 찾을떄도 level이 더 큰 노드를 maxDepth부터 0까지 반복하며 level을 맞춰나간다. 이 과정에서 노드를 i번째 부모 노드로 바꾸는 과정이 필요하다.

level이 맞다면 또한 이분탐색을 이용하여, maxDepth부터 0까지 반복하며 i번쨰 부모 노드가 다르다면 현재 노드와 교체하면서 탐색한다.

for (int i = maxDepth; i >= 0; i--) {
            if (parent[a][i] != parent[b][i]) {
                a = parent[a][i];
                b = parent[b][i];
            }
            ret = parent[a][i];
        }

이러한 방식으로 찾는데 그 이유는 간단하다.

maxDepth의 경우 부모가 같을 수 밖에 없다.

우리는 가장 가까운 공통 조상을 찾는것이기 때문에 다를때마다 갱신해주고 거기서 더 작은 상승폭으로 이분탐색하며 찾는다.
a와 b는 자연스럽게 반복문을 통해 공통 조상 바로 밑의 노드들이 될것이다. 다를때만 갱신이 되기 때문에.

만약 7번쨰 부모 노드가 LCA라면

i가 2일때 a와 b는 자신들의 4번쨰 부모노드로 갱신이 될것이다.
i가 1일때 a와 b는 자신들의 원래 노드 기준 6번쨰 부모노드로 갱신이 될것이고
i가 0일떄는 각 노드들의 1번째 부모가 같기 때문에 갱신되지 않고 ret 값은 6번쨰 부모의 바로 위 부모, 즉, 7번쨰 부모 (가장 가까운 공통 조상)을 찾을 수 있게 된다.
