철수와 민수는 카드 게임을 즐겨한다. 이 카드 게임의 규칙은 다음과 같다.

N개의 빨간색 카드가 있다. 각각의 카드는 순서대로 1부터 N까지 번호가 매겨져 있다. 이 중에서 M개의 카드를 고른다.
N개의 파란색 카드가 있다. 각각의 카드는 순서대로 1부터 N까지 번호가 매겨져 있다. 이 중에서 빨간색에서 고른 번호와 같은 파란색 카드 M개를 고른다.
철수는 빨간색 카드를 가지고 민수는 파란색 카드를 가진다.
철수와 민수는 고른 카드 중에 1장을 뒤집어진 상태로 낸다. 그리고 카드를 다시 뒤집어서 번호가 큰 사람이 이긴다. 이 동작을 K번 해서 더 많이 이긴 사람이 최종적으로 승리한다. 한 번 낸 카드는 반드시 버려야 한다.
철수는 뛰어난 마술사이기 때문에 본인이 낼 카드를 마음대로 조작할 수 있다. 즉, 카드를 버리고 민수 몰래 다시 들고 온다거나 민수한테 없는 카드를 내기도 한다.

민수는 뛰어난 심리학자이기 때문에 철수가 낼 카드를 알아낼 수 있다. 그래서 민수는 철수가 낼 카드보다 큰 카드가 있다면 그 카드들 중 가장 작은 카드를 내기로 했다.

K번 동안 철수가 낼 카드가 입력으로 주어진다. 그렇다면 민수가 어떤 카드를 낼지 출력하라. 단, 민수가 카드를 내지 못하는 경우는 없다고 가정한다.

처음에 선택한 알고리즘은 세그먼트 트리였고 시간초과로 실패하였다.
시간복잡도를 구해보자. O(MlogN + KlogN)이다. 1억이 1초 가정하였을때, 22 * 4000000 + 10000 * 22이다. 9천만이 나오는데 입출력때문에 시간초과에 걸린듯하다.

union find를 이용해서 문제를 풀었을때의 시간 복잡도를 구해보자. O(Mlog(M) + K)이다.

정렬에서 많은 시간이 사용될것이라고 예상이 된다.

lowerbound(arr.begin(), arr.end(), num+1) 에서 num보다 큰수 중 가장 작은 수의 idx를 리턴한다.
하지만 이 idx가 이미 사용된 수일수도 있다. 그렇기 때문에 parents배열에 사용할 수 있는 수중 가장 작은 수를 저장한다. find_parents는 일반 union_find와 같은 알고리즘이다.
parents[idx]가 리턴할 수의 idx이다. 처음에는 parents[i] = i로 초기화가 되어있다. 그리고 arr[parents[idx]]를 리턴한다. 그전에 parents[idx]에 새로운 부모의 idx를 넣어주는 작업이 필요하다.
parents[idx] = find_parents(parents[idx]+1)을 하면된다. find_parents(parents[idx]+1)을 하는 이유는 배열상에서 오름차순으로 정렬이 되어있다. arr[idx] 보다 큰수중 가장 작은 수는 arr[idx+1]인 셈이다.
하지만 arr[parents[idx]+1]이 이미 사용된 수일수 있다. 그렇기때문에 parents[idx]+1로 find_parents를 해주고 그 값을 parents[idx]에 변경하고 arr[parents[idx]]를 리턴해주면 사용되지 않은 num보다 큰 수중 가장 작은 수를 리턴해준다.
이 문제에서 카드를 못내는 경우는 없기 때문에 더 작은 수만 남아있는 상황은 고려하지 않아도 된다.
