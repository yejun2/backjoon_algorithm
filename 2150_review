이 문제는 제목부터 알 수 있는 Strongly Connected Components (강한 연결 요소) 이다. 
우선, scc가 무엇을 의미하는지를 먼저 확인해보자.
scc란 각 노드 가 서로 다른 노드로 갈 수 있는 길이 존재하는 연결 요소를 뜻한다. 다른 도시를 거쳐서라도 한 도시에서 다른 도시로 갈 수 있는 길이 존재한다면 이 노드들의 묶음은 scc가 된다.

방향성이 있는 그래프에서 적용된다는 점을 알 수 있다. 방향성이 없다면 끊겨있는 것이 아닌 이상, 각 도시들은 모두 길이 존재하기 떄문이다.

scc탐색을 dfs로 완전 탐색을 하게된다면 당연하게도 O(V * E)가 되어 시간 초과가 난다.
타잔 알고리즘을 통해 문제를 해결하였고, 타잔 알고리즘의 시간 복잡도는 O(N + M)이다.
scc를 탐색하기 위해서 우선 방문한적이 없는 노드들을 기준점으로 탐색해나간다.
각 노드를 방문할때에는 각자 id값을 부여하고 각 노드의 번호를 stack에 저장해둔다. chk[node]의 값을 res에 저장한 후에, 탐색과정을 거치고 그 값은 res에 반영된다.
저장해둔 값과 chk[node]의 값이 같다면 scc를 이룬다는 뜻이다. res의 값은 res와 dfs(연결된 자식)의 최솟값으로 갱신하여준다.

1->4->5->1 이런경우에는 각 id값이 1 -> 1, 4 -> 2, 5 -> 3이라면 5는 1로 변경되고 4도 dfs(5)의 값 1로 변경되고 1은 1 과 1중 최솟값 1이 될것이다.

1->6->7->2->7->3->7의 경우를 보자면 위의 과정과 똑같다. 6 -> 4, 7 -> 5, 2 -> 6, 3 -> 7의 id값을 가진다. 위와 같이 2와 3의 id값은 5를 가질것이고 scc를 형성한다.

6의 경우, 자식 7의 return된 res값은 5, 본인 값은 4이기때문에 또 혼자 scc를 형성한다고 되어 추가된다.

6의 return된 res값 4보다 1의 id값 1이 작으므로 1 4 5 scc가 형성된다.

추가로 형성된 scc와 다시 연결될 경우는 없으므로 done 배열에 scc가 완성되어 stack에서 뺄 때, done[s.top()]을 1로 변경하여준다.

우리가 작은 id값으로 설정하도록 코딩하였으므로 stack에서 나중에 빠질수록 먼저 방문한 scc의 구성 노드라는 뜻이다. 그러므로 현재 노드와 스택에서 뽑은 노드가 같다면 같은 scc에 속한 요소는 모두 뺀것이므로 중단하여주면 된다.
이렇게 하여 연결된 자식 노드를 다 탐색 후, chk[node]와 res의 값이 같다면 scc가 형성된다는 뜻이고 이를 오름차순 정렬하여 추가해준다.
마지막에 각 scc의 가장 작은 숫자의 노드로 오름차순 정렬하여 출력한다.
