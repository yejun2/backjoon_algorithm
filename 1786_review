KMP 알고리즘을 이용하는 기본적인 문제이다.

KMP 알고리즘이란 문자열 비교 알고리즘의 일종으로 완전 탐색의 높은 시간 복잡도를 해결한 알고리즘이다.

우선 기본적인 개념은 문자열 str에서 p라는 문자열을 찾는다고 가정해보자.

문자열은 접두사와 접미사로 이루어져있는데, KMP 알고리즘은 이 점을 이용한다. 
0~i (1 < i < p.size())일때, 각 구간별로 접미사와 접두사가 겹치는 부분을 체크하여 pi배열을 만들어준다.

예를 들자면, abcdab라는 p의 pi 배열을 만들어보자.

1번째 b는 겹치는게 없다.
2,3,4 번째 또한 겹치는게 없다.
5번쨰 a는 0번쨰 a와 겹친다. pi[5] = 1이 된다. 이 pi배열의 값의 의미는 str 와 p를 차례로 비교해가다가 p의 해당 idx에서 틀렸을때, p의 몇번쨰 idx부터 다시 비교해나가면 될지를 판별하는 용도이다.
6번쨰 b는 1번째 b와 겹친다. a가 겹치고 연속적으로 겹치므로 ab가 겹치므로 pi[6] = 2이다.

이를 통해 getPI 메소드를 이해해보자.

pi를 만드는 메소드인데, j를 0에서 부터 출발시켜 겹치는지 확인한다.
여기서 중요한 점은
for (int i = 1; i < m; i++) 
  while (j > 0 && p[i] != p[j]) 
      j = arr[j-1];
  }
  if (p[i] == p[j]) {
    arr[i] = ++j;
  }
}

여기서 보면 연속해서 겹치면 그만큼 많이 생략할 수 있기 때문에 j를 증가시키며 값을 저장한다.
중요한 부분은 while문을 이용해 p[i] 와 p[j]가 같을때까지 반복해주는것이다.
당연히 해당 idx에서 다를때에는 그 전 idx까지는 일치했다는 뜻이므로 pi[j-1]로 돌리는데 돌리고 또 다를 수 있다. 그때는 가장 낮은 idx로 맞춰줘야하기때문에 while문을 이용하여야 하는것이다.

이제 탐색을 하는것을 보면 단순하다.

str의idx를 i로 순환하고, p의 idx를 j로 순환한다.
하나씩 증가시키다가 붕일치하면 pi[j-1]의 위치에서 다시 탐색하고 만약 j가 p.size()-1과 같다면 찾았다는 뜻이기 때문에 ans값을 1 증가시키고 j를 pi[j] 값으로 맞추고 계속 탐색하면 된다.
