자연수 N개로 이루어진 배열 \(a_1,a_2,a_3,\dots ,a_n\)이 있다.

 \(l\)부터 \(r\)까지 부분 배열은 \(a_l,a_{l+1},\dots , a_r\) 이다.

 \(K_s\)는 부분 배열 안에 있는 자연수 \(s\)의 개수이다.

부분 배열의 힘이란 모든 자연수 \(s\)에 대해서, \(K_s \cdot K_s \cdot s\)를 합한 값이다.

배열과 부분 배열의 범위가 주어졌을 때, 각 부분 배열의 힘을 구하는 프로그램을 작성하시오.

시간제한은 3초, 메모리제한은 128MB이다.

처음 접근법은 세그먼트트리였다. 시간복잡도상 O(Qlog(N))이기 때문에 충분히 가능하다. 하지만 메모리제한에 걸린다. 부분 배열의 힘을 구하려면 세그먼트 트리에 저장하고 있는 값이 KEY-MAP 값이어야 하기 떄문에 안된다.

모스 알고리즘에 대해 찾아보고 공부하였다.
모스 알고리즘의 시간 복잡도는 O(N * sqrt(N)) 정도로 보면 된다.
모스알고리즘이랑 겹치는 구간의 계산을 기반으로 최대한 많은 구간을 겹치게하여 계산을 최소화하는 알고리즘으로 구간 배열에 많이 쓰이는것 같다. 세그먼트 트리로는 메모리상 구현할 수 없을때.
우선 쿼리를 순서대로 정리하는 것이 아닌 계산의 최소화를 위해 시작점을 sqrt(N)으로 나눈 몫을 기준으로 정렬한다. 이 값이 같은 때에는 끝점이 작은 순서로 정렬을 한다.
이렇게 하면 시작점 / sqrt(N) 이 다른 값으로 넘어갈때가 아니면 한 쿼리당 반복수를 sqrt(N) 정도로 수행할 수 있기 때문이다.

두번째로 시간초과에 걸린 부분은 map을 만들어 배열의 힘을 구했다.
하지만 그럴 필요없이 추가될때, 감소될때 카운트를 저장해놓고 원래값을 빼고 추가된 카운트 값을 기반으로 자연수의 배열의 힘을 바꾸면서 한 쿼리에 반복되는 횟수만큼의 연산만으로 답을 구할 수 있었다.

이 문제를 풀면서 느낀점은 모스 알고리즘을 확실히 써야할 문제는 어떤 문제인지 알 수 있다.
하지만 쿼리당 새롭게 추가되거나 빠지는 값들을 기반으로 연산으로 답을 구해가는 식을 구해서 문제를 푸는것이 모스 알고리즘의 포인트인것 같다.
