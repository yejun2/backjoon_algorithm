봄캠프를 마친 김진영 조교는 여러 도시를 돌며 여행을 다닐 계획이다. 그런데 김 조교는, '느림의 미학'을 중요시하는 사람이라 항상 최단경로로만 이동하는 것은 별로 좋아하지 않는다.
하지만 너무 시간이 오래 걸리는 경로도 그리 매력적인 것만은 아니어서, 적당한 타협안인 '$k$번째 최단경로'를 구하길 원한다. 그를 돕기 위한 프로그램을 작성해 보자.

처음에 문제 접근은 배열로 보아 행렬의 제곱도 잠시 생각을 해봤지만, 시간복잡도 상 문제 해결도 힘들거 같아 접었다.
두번째 접근은 다익스트라를 응용하는것이다. 다익스트라를 어떤식으로 응용할지 생각해보았다. 처음에 했던 생각도 각 정점별로 도착하는 시간이 상이한점을 이용해서 이 시간별로 계속 다익스트라를 해주는 방법도 문득 생각이 들었지만, 시간복잡도와 메모리 생각때문에 
포기하고 인터넷에서 힌트를 받았다.

두번째 접근법이 맞았다..\ㅠ 원래의 다익스트라의 시간복잡도는 우선순위 큐를 사용하였을때, O(MlogN)이므로 이걸 K번한다고 생각을 했을때 불가능이라고 생각했다.
하지만 여기서 정점의 개수를 보자. 1번도시에서 N번도시로 가는 최단경로가 모든 정점을 다 거치는것이더라도, N번만 하면 된다. 그리고 i 에서 j 로 가는것만이 유일한 길이거나 무조건 최단경로이더라도 i에 도착하는 시간이 K개라면 j로 가는 추가적인 경로는 더 이상 필요하지 않게 된다.
그래서 두번째 접근법의 시간복잡도는 O(K * N * N ) = 1억이므로 가능하다.

알고리즘 코드는 이러하다. 각 정점간 연결 요소를 저장한다.
각 정점별로 도착시간을 저장해주는 2차원 배열의 형태가 필요한데, 오름차순 정렬이 되어야한다. 그래야 K개를 초과할때 가장 시간이 많이 걸리는 경로보다 짧은지 비교하고 추가적으로 탐색을 해주어야하기때문이다.
그래서 우선순위 큐를 각 정점별로 배열로 만들었다.

다른 것은 기본적인 우선순위 큐를 사용하는 것과 동일하다.

우선순위 큐에 추가하는 조건을 알아보자. 목적지가는 시간이 K개 이하라면 추가하고 이시간으로 탐색하여야한다. 목적지로 가는 시간이 K개 이상이라면 교체해주어야한다. 제거하고 큐에 추가하고 (큐에 추가는 경로의 시간 비교를 위해) 탐색하는 큐에 넣어 탐색을 진행해주어야한다.

이 문제를 통해 배운것은 기본적으로 학습한 알고리즘을 최대한 응용하는 것이고. 응용한 방법에서 시간복잡도와 메모리 구현이 어렵다고 아니라고 생각하지 않고 확실하게 구해보는 것. 시간복잡도도 달라질수 있으니 한번 생각해볼것, 이런것을 배웠다.

------추가------

우선순위 큐를 사용하지 않고 max를 저장 개수를 저장 이렇게 하는게 메모리 적으로 더 이득을 볼 수 있지 않을까 생각했지만, 가장 큰수와 변경된 수 사이에 다른 값들이 존재할 수 있으므로 구현할 수 없다는 것을 알게되었다.
