문제의 처음 접근법은 2차원 배열을 이용하는 것이었다.
[문자의 idx][알파벳 번호]에 갯수를 카운트하여 카운트가 줄어들 때 타이핑을 쳐야하는것으로 보고 치는 것으로 구상하였다.

하지만, 다른 문자에서 출발하여 같은 문자에서 만나 카운트의 의미가 없어지는 tc를 발견하였다.
그래서 인터넷에 트라이 알고리즘을 검색하여 풀었다.
시간 복잡도는 O(N * M)이다.

트라이 알고리즘은 앞서 나온 문자의 연결관계에 따라 문자들을 정리해놓은 트리구조를 사용하는 알고리즘이다.

우선 트리란 Node클래스를 만들고, Node 클래스의 자식노드들을 저장하는 방식을 이용하는데, 이때 Node의 주소를 이용하여 저장해놓는다. (메모리적으로 훨씬 이득)

트라이 알고리즘을 사용 5670 문제의 경우에 자식 노드의 주소를 저장하는 방식을 vector로 사용한다. 자식노드가 많을 수 있기 때문이다.

반복문을 사용하여 연결 관계를 만들며 insert 할수 있고, 재귀를 이용하여 연결관계를 만들 수도 있다.

Node에 cnt라고 카운트하는 변수를 생성하였다. search기능을 위하여 만든것이다.
cnt가 앞선 문자보다 작아지면 갱신하면서 search해준다. 이 경우 타자를 쳐야하는 수에 +1인것이다.
같은 줄기에서 이 문자에서 흩어지기 때문에 이 문자는 타이핑을 쳐야한다.

트라이 알고리즘은 간단하지만, 문자의 순서가 중요한 트리를 만들 때 사용하면 된다. 시간복잡도의 경우에 O(N * M)이므로 잘 사용하면 될듯하다.
