이 문제 kmp알고리즘을 이용한 문제이고, pi배열을 이용한 문제이다.
처음에는 갈피를 못 잡았고, 결국 해답을 보고 풀게 되었다.

이 문제는 pi배열의 값이 무엇을 의미하는지에 집중하여야한다.
각 인덱스별로 pi배열의 값은 어디서부터 다시 탐색을 시작해야하는지를 알려준다.
pi[pi.size()-1]는 만들수 부분문자열 a로 s를 만들수있다는 가정하에 만들수 있는 가장 긴 문자열의 길이를 뜻한다.

예를 들어보자.
abcabca라는 문자열 s가 있다.
pi배열의 값은 [0, 0, 0, 1, 2, 3, 4]가 될것이다.

abca abca를 만들수 있다. 하지만 첫번째 abca의 마지막 a와 두번째 abca의 첫번째 a는 겹친다. 이점에서 이 문자열의 길이에 집중해본다.

다른 예를 보자.
abcabcabc라는 문자열 s가 있다.
pi배열의 값은 [0, 0, 0, 1, 2, 3, 4, 5, 6]가 될것이다.
가장 작은 a의 길이는 s.size() - pi[pi.size()-1]이 된다.
그 이유는 맨처음의 가장 작은 a는 pi배열에서 count가 되지 않는다. 그러므로 완성된 문자열의 길이 - 가장 긴 문자열a의 길이는 = a를 구성하는 가장 작은 문자열의 길이라 할 수 있다.

만약 중복되지 않고 만들수 있다면 문자열의 길이 / 가장 작은a의 길이의 나머지는 0이 될것이고 몫이 답이다.
